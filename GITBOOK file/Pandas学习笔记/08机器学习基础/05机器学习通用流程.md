
机器学习通用流程
===

本部分用于学习各种分类器使用，熟悉机器学习通用流程

机器学习步骤

1. 抽象：特征工程，获取样本数据（特征和标签）
1. 将样本数据分为训练集和测试集
1. 算法：创建分类器
1. 训练：用训练集（特征和标签）训练分类器
1. 预测：使用测试集（特征）预测标签
1. 用测试集自带的标签和预测的标签比较，评价分类器的准确率

---

上面的流程循环迭代，不断优化，准确率达标后：

7. 保存训练好的模型
1. 使用真正的待预测数据，预测标签(略）
    * 手动预测
    * 将训练好的模型保存为文件，开发为接口，给业务调用预测


```python
import numpy as np
import pandas as pd
```

## 1：获取数据，特征工程，样本数据（特征和标签）

真正工作中，这一步最耗时


```python
# 样本数据
from sklearn.datasets import load_iris  # 鸢尾花数据载入

iris = load_iris()
iris

X = iris.data  # 特征
y = iris.target  # 标签

X
```




    array([[5.1, 3.5, 1.4, 0.2],
           [4.9, 3. , 1.4, 0.2],
           [4.7, 3.2, 1.3, 0.2],
           [4.6, 3.1, 1.5, 0.2],
           [5. , 3.6, 1.4, 0.2],
           [5.4, 3.9, 1.7, 0.4],
           [4.6, 3.4, 1.4, 0.3],
           [5. , 3.4, 1.5, 0.2],
           [4.4, 2.9, 1.4, 0.2],
           [4.9, 3.1, 1.5, 0.1],
           [5.4, 3.7, 1.5, 0.2],
           [4.8, 3.4, 1.6, 0.2],
           [4.8, 3. , 1.4, 0.1],
           [4.3, 3. , 1.1, 0.1],
           [5.8, 4. , 1.2, 0.2],
           [5.7, 4.4, 1.5, 0.4],
           [5.4, 3.9, 1.3, 0.4],
           [5.1, 3.5, 1.4, 0.3],
           [5.7, 3.8, 1.7, 0.3],
           [5.1, 3.8, 1.5, 0.3],
           [5.4, 3.4, 1.7, 0.2],
           [5.1, 3.7, 1.5, 0.4],
           [4.6, 3.6, 1. , 0.2],
           [5.1, 3.3, 1.7, 0.5],
           [4.8, 3.4, 1.9, 0.2],
           [5. , 3. , 1.6, 0.2],
           [5. , 3.4, 1.6, 0.4],
           [5.2, 3.5, 1.5, 0.2],
           [5.2, 3.4, 1.4, 0.2],
           [4.7, 3.2, 1.6, 0.2],
           [4.8, 3.1, 1.6, 0.2],
           [5.4, 3.4, 1.5, 0.4],
           [5.2, 4.1, 1.5, 0.1],
           [5.5, 4.2, 1.4, 0.2],
           [4.9, 3.1, 1.5, 0.2],
           [5. , 3.2, 1.2, 0.2],
           [5.5, 3.5, 1.3, 0.2],
           [4.9, 3.6, 1.4, 0.1],
           [4.4, 3. , 1.3, 0.2],
           [5.1, 3.4, 1.5, 0.2],
           [5. , 3.5, 1.3, 0.3],
           [4.5, 2.3, 1.3, 0.3],
           [4.4, 3.2, 1.3, 0.2],
           [5. , 3.5, 1.6, 0.6],
           [5.1, 3.8, 1.9, 0.4],
           [4.8, 3. , 1.4, 0.3],
           [5.1, 3.8, 1.6, 0.2],
           [4.6, 3.2, 1.4, 0.2],
           [5.3, 3.7, 1.5, 0.2],
           [5. , 3.3, 1.4, 0.2],
           [7. , 3.2, 4.7, 1.4],
           [6.4, 3.2, 4.5, 1.5],
           [6.9, 3.1, 4.9, 1.5],
           [5.5, 2.3, 4. , 1.3],
           [6.5, 2.8, 4.6, 1.5],
           [5.7, 2.8, 4.5, 1.3],
           [6.3, 3.3, 4.7, 1.6],
           [4.9, 2.4, 3.3, 1. ],
           [6.6, 2.9, 4.6, 1.3],
           [5.2, 2.7, 3.9, 1.4],
           [5. , 2. , 3.5, 1. ],
           [5.9, 3. , 4.2, 1.5],
           [6. , 2.2, 4. , 1. ],
           [6.1, 2.9, 4.7, 1.4],
           [5.6, 2.9, 3.6, 1.3],
           [6.7, 3.1, 4.4, 1.4],
           [5.6, 3. , 4.5, 1.5],
           [5.8, 2.7, 4.1, 1. ],
           [6.2, 2.2, 4.5, 1.5],
           [5.6, 2.5, 3.9, 1.1],
           [5.9, 3.2, 4.8, 1.8],
           [6.1, 2.8, 4. , 1.3],
           [6.3, 2.5, 4.9, 1.5],
           [6.1, 2.8, 4.7, 1.2],
           [6.4, 2.9, 4.3, 1.3],
           [6.6, 3. , 4.4, 1.4],
           [6.8, 2.8, 4.8, 1.4],
           [6.7, 3. , 5. , 1.7],
           [6. , 2.9, 4.5, 1.5],
           [5.7, 2.6, 3.5, 1. ],
           [5.5, 2.4, 3.8, 1.1],
           [5.5, 2.4, 3.7, 1. ],
           [5.8, 2.7, 3.9, 1.2],
           [6. , 2.7, 5.1, 1.6],
           [5.4, 3. , 4.5, 1.5],
           [6. , 3.4, 4.5, 1.6],
           [6.7, 3.1, 4.7, 1.5],
           [6.3, 2.3, 4.4, 1.3],
           [5.6, 3. , 4.1, 1.3],
           [5.5, 2.5, 4. , 1.3],
           [5.5, 2.6, 4.4, 1.2],
           [6.1, 3. , 4.6, 1.4],
           [5.8, 2.6, 4. , 1.2],
           [5. , 2.3, 3.3, 1. ],
           [5.6, 2.7, 4.2, 1.3],
           [5.7, 3. , 4.2, 1.2],
           [5.7, 2.9, 4.2, 1.3],
           [6.2, 2.9, 4.3, 1.3],
           [5.1, 2.5, 3. , 1.1],
           [5.7, 2.8, 4.1, 1.3],
           [6.3, 3.3, 6. , 2.5],
           [5.8, 2.7, 5.1, 1.9],
           [7.1, 3. , 5.9, 2.1],
           [6.3, 2.9, 5.6, 1.8],
           [6.5, 3. , 5.8, 2.2],
           [7.6, 3. , 6.6, 2.1],
           [4.9, 2.5, 4.5, 1.7],
           [7.3, 2.9, 6.3, 1.8],
           [6.7, 2.5, 5.8, 1.8],
           [7.2, 3.6, 6.1, 2.5],
           [6.5, 3.2, 5.1, 2. ],
           [6.4, 2.7, 5.3, 1.9],
           [6.8, 3. , 5.5, 2.1],
           [5.7, 2.5, 5. , 2. ],
           [5.8, 2.8, 5.1, 2.4],
           [6.4, 3.2, 5.3, 2.3],
           [6.5, 3. , 5.5, 1.8],
           [7.7, 3.8, 6.7, 2.2],
           [7.7, 2.6, 6.9, 2.3],
           [6. , 2.2, 5. , 1.5],
           [6.9, 3.2, 5.7, 2.3],
           [5.6, 2.8, 4.9, 2. ],
           [7.7, 2.8, 6.7, 2. ],
           [6.3, 2.7, 4.9, 1.8],
           [6.7, 3.3, 5.7, 2.1],
           [7.2, 3.2, 6. , 1.8],
           [6.2, 2.8, 4.8, 1.8],
           [6.1, 3. , 4.9, 1.8],
           [6.4, 2.8, 5.6, 2.1],
           [7.2, 3. , 5.8, 1.6],
           [7.4, 2.8, 6.1, 1.9],
           [7.9, 3.8, 6.4, 2. ],
           [6.4, 2.8, 5.6, 2.2],
           [6.3, 2.8, 5.1, 1.5],
           [6.1, 2.6, 5.6, 1.4],
           [7.7, 3. , 6.1, 2.3],
           [6.3, 3.4, 5.6, 2.4],
           [6.4, 3.1, 5.5, 1.8],
           [6. , 3. , 4.8, 1.8],
           [6.9, 3.1, 5.4, 2.1],
           [6.7, 3.1, 5.6, 2.4],
           [6.9, 3.1, 5.1, 2.3],
           [5.8, 2.7, 5.1, 1.9],
           [6.8, 3.2, 5.9, 2.3],
           [6.7, 3.3, 5.7, 2.5],
           [6.7, 3. , 5.2, 2.3],
           [6.3, 2.5, 5. , 1.9],
           [6.5, 3. , 5.2, 2. ],
           [6.2, 3.4, 5.4, 2.3],
           [5.9, 3. , 5.1, 1.8]])




```python
y
```




    array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
           1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
           1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
           2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
           2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2])



## 2：将样本数据分为训练集和测试集

切分训练集测试集可以用sklearn自带方法实现，也可以手动使用Numpy方法分割（先合并特征和标签，再洗牌，再切片分割）

如果训练集和测试集内容固定，使用次数太多，会导致过拟合

* 正常拟合：成绩较高，而且模拟测试和真实场景精度一致
* 过拟合：模拟测试里成绩较高，真实场景内成绩较低（最糟糕的情况）
* 欠拟合：成绩较差，模拟测试和真实场景精度一致

更高级的方式

* 训练集、验证集、测试集
* 交叉验证


```python
from sklearn.model_selection import train_test_split

# 分割过程
# 合并特征和标签
# 洗牌，对数据行进行乱序排列
# 抽80%做训练集，20%做测试集
# 拆分，特征和标签

# 分割训练集和测试集
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=.2, random_state=5)  # 调节测试集比例，对预测准确率有影响
X_train.shape  # 训练集特征
X_test.shape  # 测试集特征
y_train.shape  # 训练集标签
y_test.shape  # 测试集标签
```




    (30,)




```python
X_train.shape
```




    (120, 4)




```python
X_test.shape
```




    (30, 4)




```python
y_train, y_test  # 注意分割后的数据集是被随机重排过的
```




    (array([0, 1, 1, 0, 1, 0, 0, 2, 0, 2, 2, 1, 0, 0, 1, 2, 1, 2, 2, 0, 2, 0,
            0, 0, 0, 1, 1, 1, 1, 2, 1, 2, 2, 1, 0, 1, 0, 1, 2, 1, 2, 1, 2, 1,
            1, 1, 2, 1, 0, 2, 0, 0, 1, 0, 0, 2, 1, 0, 2, 0, 2, 1, 0, 0, 2, 1,
            1, 0, 0, 2, 1, 1, 0, 1, 2, 1, 0, 1, 2, 2, 2, 2, 0, 0, 1, 2, 0, 1,
            0, 0, 2, 1, 2, 0, 2, 0, 2, 0, 1, 0, 2, 2, 0, 2, 2, 2, 1, 0, 1, 0,
            0, 1, 2, 0, 2, 0, 1, 2, 2, 1]),
     array([1, 2, 2, 0, 2, 1, 0, 1, 0, 1, 1, 2, 2, 2, 0, 0, 2, 2, 0, 0, 1, 2,
            0, 1, 1, 2, 1, 1, 1, 2]))



## 3：算法：创建分类器

* 整个scikit-learn机器学习预测项目流程里，只有这个cell的内容替换成不同分类器算法即可，上面下面cell的代码都不需要改变，因为sklearn内的分类器api接口非常相似

注：仅适用于分类器（无监督学习如聚类算法没有x）


```python
# 决策树
# from sklearn import tree
# my_classifier = tree.DecisionTreeClassifier()  # 创建空分类器
# my_classifier

# 逻辑回归
# from sklearn.linear_model import LogisticRegression
# my_classifier =  LogisticRegression(multi_class='auto', solver='lbfgs')
# my_classifier

# KNN
from sklearn.neighbors import KNeighborsClassifier
# my_classifier = KNeighborsClassifier()
my_classifier = KNeighborsClassifier(n_neighbors=8)  # 调参
my_classifier
```




    KNeighborsClassifier(algorithm='auto', leaf_size=30, metric='minkowski',
                         metric_params=None, n_jobs=None, n_neighbors=8, p=2,
                         weights='uniform')




```python
# LogisticRegression?
```

## 4：训练：用训练集（特征和标签）训练分类器


```python
my_classifier.fit(X_train, y_train)
```




    KNeighborsClassifier(algorithm='auto', leaf_size=30, metric='minkowski',
                         metric_params=None, n_jobs=None, n_neighbors=8, p=2,
                         weights='uniform')



## 5：预测：使用测试集（特征）预测标签


```python
predictions = my_classifier.predict(X_test)
predictions
```




    array([1, 2, 2, 0, 2, 1, 0, 1, 0, 1, 1, 2, 2, 2, 0, 0, 2, 2, 0, 0, 1, 2,
           0, 1, 1, 2, 1, 1, 1, 2])




```python
y_test  # 真正的测试集标签
```




    array([1, 2, 2, 0, 2, 1, 0, 1, 0, 1, 1, 2, 2, 2, 0, 0, 2, 2, 0, 0, 1, 2,
           0, 1, 1, 2, 1, 1, 1, 2])



## 6：用测试集自带的标签和预测的标签比较，评价分类器的准确率

手动计算


```python
predictions == y_test
```




    array([ True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True])




```python
y_test.shape[0] # 总数
```




    30




```python
np.sum(predictions == y_test) / y_test.shape[0]
```




    1.0




```python
28 / 30
```




    0.9333333333333333




```python
# 自动计算准确率
from sklearn.metrics import accuracy_score

accuracy_score(y_test, predictions)
```




    1.0



者直接使用 模型.score()方法 直接预测出精度

没有预测标签，直接计算精度


```python
my_classifier.score(X_test, y_test)
```




    1.0




```python

```

## 7：保存训练好的模型


```python
import joblib  # 需要安装 pip install joblib
```


```python
# 训练好的模型
my_classifier
```




    KNeighborsClassifier(algorithm='auto', leaf_size=30, metric='minkowski',
                         metric_params=None, n_jobs=None, n_neighbors=8, p=2,
                         weights='uniform')




```python
# 保存模型
joblib.dump(my_classifier, 'model.pkl')
```




    ['model.pkl']



重新载入训练好的模型


```python
mc = joblib.load('model.pkl')
mc
```




    KNeighborsClassifier(algorithm='auto', leaf_size=30, metric='minkowski',
                         metric_params=None, n_jobs=None, n_neighbors=8, p=2,
                         weights='uniform')




```python
# 用载入的模型预测
mc.predict(X_test)
```




    array([1, 2, 2, 0, 2, 1, 0, 1, 0, 1, 1, 2, 2, 2, 0, 0, 2, 2, 0, 0, 1, 2,
           0, 1, 1, 2, 1, 1, 1, 2])



## 8：使用真正的待预测数据，预测标签（略）

* 手动预测
* 将训练好的模型保存为文件，开发为接口，给业务调用预测


```python

```
